32 REGS:
eax	(0) 	---- 	ah	(10)	----	16
ebx	(1)	---- 	bh	(11)	----	16
ecx	(2)	---- 	ch	(12)	----	16
edx	(3) 	----	dh	(13)	----	16

ip	(4)	----	16
esp	(5)	----	32

COMMANDS:
mov

add
sub
mul 	---- 	eax	*	reg 	---->	eax
div	---- 	eax	/	reg 	----> 	eax - i edx - f

inc
dec

ror/rol
shr/shl

push
pop

label:
jmp

je/jne
jb/jl
jbe/jle
jnb/jnl

cmp

int

call
ret

and
or
xor
not

RESULT TO THE FIRST OPERAND

SYMBOLS:
,
[]
:

INTERRUPTS:
int 10
use ah:
10 	-		print one symbol while dh != ah
11 	-		scan one symbol while dh != ah

int 16
use ah:
09 	-		scan integer to the top of the stack
10 	-		scan float integer part to eax floating part to edx
11 	-		scan symbols to [dh] while != 24

int 21
use ah:
44 	-		close
09 	-		print integer - top of the stack
10 	-		print float - first and second elements from the stack. Sep by '.'
11 	-		print symbols while  dh != 24

Opcodes:
OP_MOV_1	1		-		mov 	reg,		reg
OP_MOV_2	2		-		mov	reg,		integer
OP_MOV_3	3 		-		mov 	reg,		[reg]
OP_MOV_4	4		-		mov	[reg],		reg

	ARITHMETIC

OP_ADD_1	5		-		add	reg, 		reg
OP_ADD_2	6		-		add	reg,		integer
OP_ADD_3	7		-		add	reg,		[reg]
OP_ADD_4	8		-		add	[reg],		reg

OP_SUB_1	9		-		sub	reg, 		reg
OP_SUB_2	10		-		sub	reg,		integer
OP_SUB_3	11		-		sub	reg,		[reg]
OP_SUB_4	12		-		sub	[reg],		reg

OP_MUL_1	13		-		mul 	reg
OP_MUL_2	14		-		mul	integer
OP_MUL_3	15		-		mul	[reg]

OP_DIV_1	16		-		div	reg
OP_DIV_2	17		-		div	integer
OP_DIV_3	18		-		div	[reg]


OP_INC_1	19 		-		inc 	reg
OP_INC_2	20		-		inc	[reg]

OP_DEC_1	21 		-		dec	reg
OP_DEC_2	22 		-		dec	[reg]

	SHIFT

OP_ROR		30		-		ror	reg,		cl
OP_ROL		31		-		rol	reg,		cl

OP_SHR		32		-		shr	reg,		cl
OP_SHL		33		-		shl	reg,		cl

	STACK

OP_PUSH_1	40		-		push	reg
OP_PUSH_2	41		-		push	integer
OP_PUSH_3	42		-		push	[reg]
OP_POP_1	43		-		pop	reg
OP_POP_2	44		-		pop	[reg]
OP_DSTACK	45		-		.stack	integer

	LABELS
	
OP_JMP_1	50		-		jmp	integer
OP_JMP_2	51		-		jmp	[integer]
	
OP_JE_1		52		-		je	integer
OP_JE_2		53		-		je	[integer]

OP_JNE_1	54		-		jne	integer
OP_JNE_2	55		-		jne	[integer]

OP_JB_1		56		-		jb	integer
OP_JB_2		57		-		jb	[integer]
OP_JL_1		58		-		jl	integer
OP_JL_2		59		-		jl	[integer]

OP_JBE_1	60		-		jbe	integer
OP_JBE_2	61		-		jbe	[integer]
OP_JLE_1	62		-		jle	integer
OP_JLE_2	63		-		jle	[integer]

OP_JNB_1	64		-		jnb	integer
OP_JNB_2	65		-		jnb	[integer]
OP_JNL_1	66		-		jnl	integer
OP_JNL_2	67		-		jnl	[integer]

OP_CMP_1	68		-		cmp	reg,		reg
OP_CMP_2	69		-		cmp	reg,		integer
OP_CMP_3	70		-		cmp	reg,		[reg]

	INTERRUPT

OP_INT		75		- 		int 	integer

	FUNCS
	
OP_CALL_1	80		-		call	integer
OP_CALL_2	81		-		call	[integer]
OP_RET		82		-		ret

	LOGIC
	
OP_AND_1	90 		-		and 	reg,		reg
OP_AND_2	91		-		and 	reg,		integer
OP_AND_3	92 		-		and 	reg,		[reg]

OP_OR_1		93		-		or	reg,		reg
OP_OR_2		94		-		or	reg,		integer
OP_OR_3		95		-		or	reg,		[reg]

OP_XOR_1	96		-		xor	reg,		reg
OP_XOR_2	97		-		xor	reg,		integer
OP_XOR_3	98		-		xor	reg,		[reg]

OP_NOT		99		-		not	reg
